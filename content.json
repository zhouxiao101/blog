{"meta":{"title":"记录","subtitle":"敲代码的小行家","description":"代码使我快乐","author":"周潇","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"React生命周期","slug":"React生命周期","date":"2018-07-24T06:47:29.777Z","updated":"2018-07-27T02:44:07.486Z","comments":true,"path":"2018/07/24/React生命周期/","link":"","permalink":"http://yoursite.com/2018/07/24/React生命周期/","excerpt":"","text":"1,getDefaultProps()1设置默认的props，也可以用defaultProps设置组件的默认属性。 2,getInitialState()1在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state. 3,componentWillMount()1组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state. 4,render()1react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5，componentDidMount()1组件渲染之后调用，只调用一次 6，componentWillReceiveProps(nextProps)1组件初始化时不调用，组件接受新的props时调用 7，shouldComponentUpdate(nextProps,nextState)1234react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false组织更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 8,componentWillUpdata(nextProps,nextState)1组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9，render()1组件渲染 10,componentDidUpdate()1组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 11,componentWillUnmount()1组件将要卸载时调用，一些事件监听和定时器需要在此时清除","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"面试总结（一）","slug":"面试题总结（一）","date":"2018-07-24T06:30:29.865Z","updated":"2018-07-27T02:43:44.800Z","comments":true,"path":"2018/07/24/面试题总结（一）/","link":"","permalink":"http://yoursite.com/2018/07/24/面试题总结（一）/","excerpt":"","text":"1，严格模式和非严格模式有什么区别？12345678910严格模式的编译指示： &quot;use strict&quot;1,不使用var声明变量严格模式中将不通过，在循环中如果没有声明变量在非严格模式中很危险，i 会不小心溢出成为全局变量但在严格模式中会报错，严格模式中变量必须显示声明(var/let/const)2,JS中作用域有两种，全局作用域和函数作用域。严格模式带来了第三种作用域：eval作用域，则任何使用&apos;eval&apos;的操作都会被禁止,(eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码,不常用容易报错)，在严格模式下，arguments和eval是关键字，不能被修改，不能做变量处理3,对象有重名的属性将报错4,函数有重名的参数将报错，在严格模式下，函数的形参也不可以同名5,call/apply/bind的第一个参数为null/undefined时，this为null/undefined... 2，ES6中的类和构造函数的区别 3，同步和异步的区别 4，ajax的优缺点 5，ajax多并发怎么处理 6，常用的几种算法 7，描述事件委托处理机制 还可以称为事件代理，把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务，事件代理的原理是DOM事件冒泡。使用事件委托的好处是可以提高性能。 延伸：事件冒泡就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，指导document/window，冒泡过程。 8，前端如何实现模块化 9，jsonp工作原理 10，CMD与AMD比较 11，css合并方法 12，简述css盒子模型 13，圣杯布局和双飞翼布局的理解和区别 14，如何实现前后端分离协同开发 15，前端性能优化的一些方法 16，对CSRF的理解 17，如何应用一个前端框架在项目中 18，expires,cache-control,last-modified,etag 如何选择使用 19，递归 20，闭包 函数执行的时候会形成一个私有作用域，保护里面的私有变量不受外界干扰，这种保护机制叫做闭包。 21，常见的HTTP状态码 1xx：临时响应。表示临时响应并需要请求者继续执行操作的状态码 2xx：成功。表示成功处理了请求的状态码 3xx：重定向。要完成请求需要进一步操作 4xx：请求错误。这些状态码表示请求出错，妨碍了服务器的处理 5xx：服务器错误。这些状态吗表示服务器在处理请求的时候发生内部错误。 200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 301（永久移动）：请求的网页已永久移动到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。 304（未修改）：自从上次请求后，请求的网页未修改过。 400（错误请求）：服务器不理解请求的语法。 404（未找到）：服务器找不到请求的网页。 500（服务器内部错误）：服务器遇到错误，无法完成请求。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 22，怎么区分react，angular，vue 什么情况下用 23，变量提声 预解释。在当前作用域中，JS代码自上而下执行之前，浏览器会把带有var/function关键字的，进行提前声明定义， 24，","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/tags/面试总结/"}]},{"title":"数组去重","slug":"数组去重","date":"2018-06-28T07:59:58.549Z","updated":"2018-07-27T02:43:09.162Z","comments":true,"path":"2018/06/28/数组去重/","link":"","permalink":"http://yoursite.com/2018/06/28/数组去重/","excerpt":"","text":"方案一：遍历数组中的每一项，拿每一项和它后面的项依次比较，如果相同了，则把相同的这一项在原来数组中删除12345678910var ary=[1,1,2,2,3,3,4,2,2,2,2,2,3,3,3,4,4,4,1,1];for(var i=0;i&lt;ary.length-1;i++)&#123; var cur=ary[i]; for (var j=i+1;j&lt;ary.length;j++)&#123; if(cur==ary[j])&#123; ary.splice(j,1) j--; &#125; &#125;&#125; 方案二：利用indexOf来验证当前数组中是否包含某一项，包含把当前项删除掉(不兼容IE6~8)123456789101112var ary=[5,5,3,1,1,2,2,3,3,4,2,2,2,2,2,3,3,3,4,4,4,];for(var i=0;i&lt;ary.length;i++)&#123; var cur=ary[i]; var next=ary.slice(i+1); if(next.indexOf(cur)&gt;-1)&#123; ary.splice(i,1); i--; &#125;&#125;console.log(ary.sort(function(a,b)&#123; return a-b;&#125;)) 方案三：遍历数组中的每一项，把每一项作为新对象的属性名和属性值存储起来，例如：当前项1，对象中存储{1:1}在每一次向对象中存储之前，首先看一下原有对象中是否包含了这个属性(typeof obj[xxx]===&#39;undefined&#39;说明当前对象中没有xxx这个属性)，如果已经存在这个属性说明数组中的当前项是重复的(1-在原有数组中删除这一项 2-不再像对象中存储这个结果)，如果不存在，把当前项作为对象的属性名和属性值存储进去12345678910111213var ary=[5,5,3,1,1,2,2,3,3,4,2,2,2,2,2,3,3,3,4,4,4,];var obj=&#123;&#125;;for(var i=0;i&lt;ary.length;i++)&#123; var cur=ary[i]; if(typeof obj[cur]!=='undefined')&#123; ary[i]=ary[ary.length-1];//用splice删除当前项，会让后面所有项向前挪一位（用最后一项代替重复项，后面所有项不受影响） ary.length--;//删除数组最后一项 i--; continue; &#125; obj[cur]=cur;&#125; 方案四：相邻比较法，首先给数组进行排序，然后相邻两项比较，相同的话把后一项在数组中去掉 12345678910var ary=[5,5,3,1,1,2,2,3,3,4,2,2,2,2,2,3,3,3,4,4,4,];ary.sort(function(a,b)&#123; return a-b;&#125;)var aryCur=[ary[0]];for(var i=1;i&lt;ary.length;i++)&#123; if(ary[i]!==aryCur[aryCur.length-1])&#123; aryCur.push(ary[i]) &#125;&#125;","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"数组基础","slug":"Array","date":"2018-06-28T07:56:24.575Z","updated":"2018-07-27T02:41:02.473Z","comments":true,"path":"2018/06/28/Array/","link":"","permalink":"http://yoursite.com/2018/06/28/Array/","excerpt":"","text":"类数组：类似于数组，但是不是数组1.通过getElementsByTagName获取的元素集合是类数组2.函数中的实参集合arguments也是类数组 for循环只能遍历到数组私有的一些属性，而for in 循环可以把一些自定义的公共属性也能遍历到 ####数组中的常用方法console.dir(Array.prototype)数组中的方法都定义在原型上，通过dir可以查看数组中的方法 12345678910111213141516171819202122232425262728293031//=&gt;增加1.push:向数组的末尾追加新内容 参数：一到多个，任何数据类型都可以 返回值：新增后数组的长度 原有数组发生改变2.unshift:向数组开头追加新内容 参数：需要追加的内容，可以是多个任何数据类型的值 返回值：新增后数组的长度 原有数组发生改变 3.把数组当做一个普通的对象，使用对象键值对的操作，给其设置新的属性（索引） ary[ary.length]=xxx 向数组的末尾追加了新的内容 //=&gt;删除1.pop:删除数组最后一项 参数：无 返回值：被删除的那一项 原有数组发生改变2.shift:删除数组第一项 参数：无 返回值：被删除的那一项 原数组发生改变3.把数组当做普通的对象操作 delete删除：delete ary[索引] 删除指定索引这一项 当前想被删除后，原有数组其它项的索引不会改变 当前数组的length也不会改变 ary.length--;删除数组最后一项 //=&gt; splice:数组中内置的方法，可以实现数组的增加，修改，删除 splice实现删除 splice(n,m)：从索引n开始删除m个 m不写是删除到数组的末尾，","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-28T07:41:51.539Z","updated":"2018-06-28T07:41:51.540Z","comments":true,"path":"2018/06/28/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}